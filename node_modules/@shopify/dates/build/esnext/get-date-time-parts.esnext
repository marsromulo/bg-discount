import { applyDecoratedDescriptor as _applyDecoratedDescriptor } from './_virtual/_rollupPluginBabelHelpers.esnext';
import { memoize } from '@shopify/decorators';
import { sanitiseDateString } from './sanitise-date-string.esnext';
import { formatDate } from './utilities/formatDate.esnext';

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class;
const TWO_DIGIT_REGEX = /(\d{2})/;
function getDateTimeParts(date, timeZone) {
  return {
    year: () => DateTimeParts.getYear(date, timeZone),
    month: () => DateTimeParts.getMonth(date, timeZone),
    day: () => DateTimeParts.getDay(date, timeZone),
    weekday: () => DateTimeParts.getWeekday(date, timeZone),
    hour: () => DateTimeParts.getHour(date, timeZone),
    minute: () => DateTimeParts.getMinute(date, timeZone),
    second: () => DateTimeParts.getSecond(date, timeZone)
  };
}

function dateTimeCacheKey(unit) {
  return (date, timeZone) => `${unit}-${date.toString()}-${timeZone}`;
}

var Weekday;

(function (Weekday) {
  Weekday["Monday"] = "Monday";
  Weekday["Tuesday"] = "Tuesday";
  Weekday["Wednesday"] = "Wednesday";
  Weekday["Thursday"] = "Thursday";
  Weekday["Friday"] = "Friday";
  Weekday["Saturday"] = "Saturday";
  Weekday["Sunday"] = "Sunday";
})(Weekday || (Weekday = {}));

const weekdays = {
  Monday: 0,
  Tuesday: 1,
  Wednesday: 2,
  Thursday: 3,
  Friday: 4,
  Saturday: 5,
  Sunday: 6
};

function isWeekday(weekday) {
  return Object.keys(weekdays).some(key => key === weekday);
}

function assertNever(message) {
  throw new Error(message);
}

function getWeekdayValue(weekday) {
  if (!isWeekday(weekday)) {
    return assertNever(`Unexpected weekday: ${weekday}`);
  }

  return weekdays[weekday];
} // eslint-disable-next-line @typescript-eslint/no-extraneous-class


let DateTimeParts = (_dec = memoize(dateTimeCacheKey('year')), _dec2 = memoize(dateTimeCacheKey('month')), _dec3 = memoize(dateTimeCacheKey('day')), _dec4 = memoize(dateTimeCacheKey('weekday')), _dec5 = memoize(dateTimeCacheKey('hour')), _dec6 = memoize(dateTimeCacheKey('minute')), _dec7 = memoize(dateTimeCacheKey('second')), _dec8 = memoize(dateTimeCacheKey('timePartsFallback')), (_class = class DateTimeParts {
  static getYear(date, timeZone) {
    if (isNaN(date.valueOf())) {
      throw new Error(`Unable to parse date: ${date} for timezone: ${timeZone}`);
    }

    const yearString = formatDate(date, 'en', {
      timeZone,
      year: 'numeric'
    });
    const sanitisedYearString = sanitiseDateString(yearString);
    const year = parseInt(sanitisedYearString, 10);

    if (isNaN(year)) {
      throw new Error(`Unable to parse year: '${yearString}'`);
    }

    return year;
  }

  static getMonth(date, timeZone) {
    const monthString = formatDate(date, 'en', {
      timeZone,
      month: 'numeric'
    });
    const sanitisedMonthString = sanitiseDateString(monthString);
    const month = parseInt(sanitisedMonthString, 10);

    if (isNaN(month)) {
      throw new Error(`Unable to parse month: '${monthString}'`);
    }

    return month;
  }

  static getDay(date, timeZone) {
    const dayString = formatDate(date, 'en', {
      timeZone,
      day: 'numeric'
    });
    const sanitisedDayString = sanitiseDateString(dayString);
    const day = parseInt(sanitisedDayString, 10);

    if (isNaN(day)) {
      throw new Error(`Unable to parse day: '${dayString}'`);
    }

    return day;
  }

  static getWeekday(date, timeZone) {
    const weekdayString = formatDate(date, 'en', {
      timeZone,
      weekday: 'long'
    });
    const sanitisedWeekdayString = sanitiseDateString(weekdayString);
    return getWeekdayValue(sanitisedWeekdayString);
  }

  static getHour(date, timeZone) {
    const hourString = formatDate(date, 'en', {
      timeZone,
      hour12: false,
      hour: 'numeric'
    });
    let hour = parseInt(hourString, 10);

    if (isNaN(hour)) {
      hour = DateTimeParts.getTimePartsFallback(date, timeZone).hour;
    }

    return hour;
  }

  static getMinute(date, timeZone) {
    const minuteString = formatDate(date, 'en', {
      timeZone,
      minute: 'numeric'
    });
    let minute = parseInt(minuteString, 10);

    if (isNaN(minute)) {
      minute = DateTimeParts.getTimePartsFallback(date, timeZone).minute;
    }

    return minute;
  }

  static getSecond(date, timeZone) {
    const secondString = formatDate(date, 'en', {
      timeZone,
      second: 'numeric'
    });
    let second = parseInt(secondString, 10);

    if (isNaN(second)) {
      second = DateTimeParts.getTimePartsFallback(date, timeZone).second;
    }

    return second;
  }

  static getTimePartsFallback(date, timeZone) {
    const timeString = formatDate(date, 'en', {
      timeZone,
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }); // In Microsoft Edge, Intl.DateTimeFormat returns invisible characters around the individual numbers

    const [dirtyHour, dirtyMinute, dirtySecond] = timeString.split(':');
    const rawHour = new RegExp(TWO_DIGIT_REGEX).exec(dirtyHour);
    const rawMinute = new RegExp(TWO_DIGIT_REGEX).exec(dirtyMinute);
    const rawSecond = new RegExp(TWO_DIGIT_REGEX).exec(dirtySecond);

    if (rawHour != null && rawMinute != null && rawSecond != null) {
      const hour = parseInt(rawHour[1], 10);
      const minute = parseInt(rawMinute[1], 10);
      const second = parseInt(rawSecond[1], 10);
      return {
        hour,
        minute,
        second
      };
    }

    throw new Error(`Unable to parse timeString: '${timeString}'`);
  }

}, (_applyDecoratedDescriptor(_class, "getYear", [_dec], Object.getOwnPropertyDescriptor(_class, "getYear"), _class), _applyDecoratedDescriptor(_class, "getMonth", [_dec2], Object.getOwnPropertyDescriptor(_class, "getMonth"), _class), _applyDecoratedDescriptor(_class, "getDay", [_dec3], Object.getOwnPropertyDescriptor(_class, "getDay"), _class), _applyDecoratedDescriptor(_class, "getWeekday", [_dec4], Object.getOwnPropertyDescriptor(_class, "getWeekday"), _class), _applyDecoratedDescriptor(_class, "getHour", [_dec5], Object.getOwnPropertyDescriptor(_class, "getHour"), _class), _applyDecoratedDescriptor(_class, "getMinute", [_dec6], Object.getOwnPropertyDescriptor(_class, "getMinute"), _class), _applyDecoratedDescriptor(_class, "getSecond", [_dec7], Object.getOwnPropertyDescriptor(_class, "getSecond"), _class), _applyDecoratedDescriptor(_class, "getTimePartsFallback", [_dec8], Object.getOwnPropertyDescriptor(_class, "getTimePartsFallback"), _class)), _class));

export { getDateTimeParts };
