'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var dates = require('@shopify/dates');
var decorators = require('@shopify/decorators');
var i18n = require('@shopify/i18n');
var types = require('./types.js');
var index = require('./constants/index.js');
var errors = require('./errors.js');
var translate = require('./utilities/translate.js');
var currencyDecimalPlaces = require('./constants/currency-decimal-places.js');
var money = require('./utilities/money.js');
var string = require('./utilities/string.js');

const _excluded = ["as", "precision"],
      _excluded2 = ["form"],
      _excluded3 = ["style"];

var _dec, _class;
// Used for currencies that don't use fractional units (eg. JPY)
const PERIOD = '.';
const NEGATIVE_SIGN = '-';
const REGEX_DIGITS = /\d/g;
const REGEX_NON_DIGITS = /\D/g;
const REGEX_PERIODS = /\./g;
let I18n = (_dec = decorators.memoize(), (_class = class I18n {
  get language() {
    return i18n.languageFromLocale(this.locale);
  }

  get region() {
    return i18n.regionFromLocale(this.locale);
  }
  /**
   * @deprecated Use I18n#region instead.
   */


  get countryCode() {
    return i18n.regionFromLocale(this.locale);
  }

  get languageDirection() {
    return index.RTL_LANGUAGES.includes(this.language) ? types.LanguageDirection.Rtl : types.LanguageDirection.Ltr;
  }

  get isRtlLanguage() {
    return this.languageDirection === types.LanguageDirection.Rtl;
  }

  get isLtrLanguage() {
    return this.languageDirection === types.LanguageDirection.Ltr;
  }

  constructor(translations, {
    locale,
    currency: _currency,
    timezone,
    country,
    pseudolocalize = false,
    onError,
    loading
  }) {
    this.translations = translations;
    this.locale = void 0;
    this.pseudolocalize = void 0;
    this.defaultCountry = void 0;
    this.defaultCurrency = void 0;
    this.defaultTimezone = void 0;
    this.onError = void 0;
    this.loading = void 0;

    this.getCurrencySymbol = currencyCode => {
      const currency = currencyCode || this.defaultCurrency;

      if (currency == null) {
        throw new errors.MissingCurrencyCodeError('formatCurrency cannot be called without a currency code.');
      }

      return this.getCurrencySymbolLocalized(this.locale, currency);
    };

    this.locale = locale;
    this.defaultCountry = country;
    this.defaultCurrency = _currency;
    this.defaultTimezone = timezone;
    this.pseudolocalize = pseudolocalize;
    this.onError = onError || this.defaultOnError;
    this.loading = loading || false;
  }

  translate(id, optionsOrReplacements, replacements) {
    const {
      pseudolocalize
    } = this;
    let normalizedOptions;

    if (optionsOrReplacements == null) {
      normalizedOptions = {
        pseudotranslate: pseudolocalize
      };
    } else if (this.isTranslateOptions(optionsOrReplacements)) {
      normalizedOptions = _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, optionsOrReplacements), {}, {
        replacements,
        pseudotranslate: pseudolocalize
      });
    } else {
      normalizedOptions = {
        replacements: optionsOrReplacements,
        pseudotranslate: pseudolocalize
      };
    }

    try {
      return translate.translate(id, normalizedOptions, this.translations, this.locale);
    } catch (error) {
      this.onError(error);
      return '';
    }
  }

  getTranslationTree(id, replacements) {
    try {
      if (!replacements) {
        return translate.getTranslationTree(id, this.translations, this.locale);
      }

      return translate.getTranslationTree(id, this.translations, this.locale, replacements);
    } catch (error) {
      this.onError(error);
      return '';
    }
  }

  translationKeyExists(id) {
    try {
      translate.getTranslationTree(id, this.translations, this.locale);
      return true;
    } catch (error) {
      return false;
    }
  }

  formatNumber(amount, _ref = {}) {
    let {
      as,
      precision
    } = _ref,
        options = _rollupPluginBabelHelpers.objectWithoutProperties(_ref, _excluded);

    const {
      locale,
      defaultCurrency: currency
    } = this;

    if (as === 'currency' && currency == null && options.currency == null) {
      this.onError(new errors.MissingCurrencyCodeError(`formatNumber(amount, {as: 'currency'}) cannot be called without a currency code.`));
      return '';
    }

    return translate.memoizedNumberFormatter(locale, _rollupPluginBabelHelpers.objectSpread2({
      style: as,
      maximumFractionDigits: precision,
      currency
    }, options)).format(amount);
  }

  unformatNumber(input) {
    const {
      decimalSymbol
    } = this.numberSymbols();
    const normalizedValue = this.normalizedNumber(input, decimalSymbol);
    return normalizedValue === '' ? '' : parseFloat(normalizedValue).toString();
  }

  formatCurrency(amount, _ref2 = {}) {
    let {
      form
    } = _ref2,
        options = _rollupPluginBabelHelpers.objectWithoutProperties(_ref2, _excluded2);

    switch (form) {
      case 'auto':
        return this.formatCurrencyAuto(amount, options);

      case 'explicit':
        return this.formatCurrencyExplicit(amount, options);

      case 'short':
        return this.formatCurrencyShort(amount, options);

      case 'none':
        return this.formatCurrencyNone(amount, options);
    }

    return this.formatNumber(amount, _rollupPluginBabelHelpers.objectSpread2({
      as: 'currency'
    }, options));
  }

  unformatCurrency(input, currencyCode) {
    const {
      decimalSymbol
    } = this.numberSymbols();
    const decimalPlaces = currencyDecimalPlaces["default"].get(currencyCode.toUpperCase());
    const normalizedValue = this.normalizedNumber(input, decimalSymbol, decimalPlaces);

    if (normalizedValue === '') {
      return '';
    }

    if (decimalPlaces === 0) {
      const roundedAmount = parseFloat(normalizedValue).toFixed(0);
      return `${roundedAmount}.${'0'.repeat(currencyDecimalPlaces.DEFAULT_DECIMAL_PLACES)}`;
    }

    return parseFloat(normalizedValue).toFixed(decimalPlaces);
  }

  formatPercentage(amount, options = {}) {
    return this.formatNumber(amount, _rollupPluginBabelHelpers.objectSpread2({
      as: 'percent'
    }, options));
  }

  formatDate(date, options = {}) {
    const {
      locale,
      defaultTimezone
    } = this;
    const {
      timeZone = defaultTimezone
    } = options;

    const _ref3 = options || {},
          {
      style = undefined
    } = _ref3,
          formatOptions = _rollupPluginBabelHelpers.objectWithoutProperties(_ref3, _excluded3);

    if (style) {
      return style === index.DateStyle.Humanize ? this.humanizeDate(date, _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, formatOptions), {}, {
        timeZone
      })) : this.formatDate(date, _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, formatOptions), index.dateStyle[style]));
    }

    return dates.formatDate(date, locale, _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, formatOptions), {}, {
      timeZone
    }));
  }

  ordinal(amount) {
    const {
      locale
    } = this;
    const group = translate.memoizedPluralRules(locale, {
      type: 'ordinal'
    }).select(amount);
    return this.translate(group, {
      scope: 'ordinal'
    }, {
      amount
    });
  }

  weekStartDay(argCountry) {
    const country = argCountry || this.defaultCountry;

    if (!country) {
      throw new errors.MissingCountryError('weekStartDay() cannot be called without a country code.');
    }

    return index.WEEK_START_DAYS.get(country) || index.DEFAULT_WEEK_START_DAY;
  }

  getCurrencySymbolLocalized(locale, currency) {
    return money.getCurrencySymbol(locale, {
      currency
    });
  }

  formatName(firstName, lastName, options) {
    if (!firstName) {
      return lastName || '';
    }

    if (!lastName) {
      return firstName;
    }

    const isFullName = Boolean(options && options.full);
    const customNameFormatter = index.EASTERN_NAME_ORDER_FORMATTERS.get(this.locale) || index.EASTERN_NAME_ORDER_FORMATTERS.get(this.language);

    if (customNameFormatter) {
      return customNameFormatter(firstName, lastName, isFullName);
    }

    if (isFullName) {
      return `${firstName} ${lastName}`;
    }

    return firstName;
  }

  hasEasternNameOrderFormatter() {
    const easternNameOrderFormatter = index.EASTERN_NAME_ORDER_FORMATTERS.get(this.locale) || index.EASTERN_NAME_ORDER_FORMATTERS.get(this.language);
    return Boolean(easternNameOrderFormatter);
  }

  numberSymbols() {
    const formattedNumber = this.formatNumber(123456.7, {
      maximumFractionDigits: 1,
      minimumFractionDigits: 1
    });
    let thousandSymbol;
    let decimalSymbol;

    for (const char of formattedNumber) {
      if (isNaN(parseInt(char, 10))) {
        if (thousandSymbol) decimalSymbol = char;else thousandSymbol = char;
      }
    }

    return {
      thousandSymbol,
      decimalSymbol
    };
  }

  formatCurrencyAuto(amount, options = {}) {
    // use the short format if we can't determine a currency match, or if the
    // currencies match, use explicit when the currencies definitively do not
    // match.
    const formatShort = options.currency == null || this.defaultCurrency == null || options.currency === this.defaultCurrency;
    return formatShort ? this.formatCurrencyShort(amount, options) : this.formatCurrencyExplicit(amount, options);
  }

  formatCurrencyExplicit(amount, options = {}) {
    const value = this.formatCurrencyShort(amount, options);
    const isoCode = options.currency || this.defaultCurrency || '';

    if (value.includes(isoCode)) {
      return value;
    }

    return `${value} ${isoCode}`;
  }

  formatCurrencyShort(amount, options = {}) {
    const formattedAmount = this.formatCurrencyNone(amount, options);
    const shortSymbol = this.getShortCurrencySymbol(options.currency);
    const formattedWithSymbol = shortSymbol.prefixed ? `${shortSymbol.symbol}${formattedAmount}` : `${formattedAmount}${shortSymbol.symbol}`;
    return amount < 0 ? `-${formattedWithSymbol.replace(/[-−]/, '')}` : formattedWithSymbol;
  }

  formatCurrencyNone(amount, options = {}) {
    const {
      locale
    } = this;
    let adjustedPrecision = options.precision;

    if (adjustedPrecision === undefined) {
      const currency = options.currency || this.defaultCurrency || '';
      adjustedPrecision = currencyDecimalPlaces["default"].get(currency.toUpperCase());
    }

    return translate.memoizedNumberFormatter(locale, _rollupPluginBabelHelpers.objectSpread2({
      style: 'decimal',
      minimumFractionDigits: adjustedPrecision,
      maximumFractionDigits: adjustedPrecision
    }, options)).format(amount);
  } // Intl.NumberFormat sometimes annotates the "currency symbol" with a country code.
  // For example, in locale 'fr-FR', 'USD' is given the "symbol" of " $US".
  // This method strips out the country-code annotation, if there is one.
  // (So, for 'fr-FR' and 'USD', the return value would be " $").
  //
  // For other currencies, e.g. CHF and OMR, the "symbol" is the ISO currency code.
  // In those cases, we return the full currency code without stripping the country.


  getShortCurrencySymbol(currencyCode = this.defaultCurrency || '') {
    const currency = currencyCode || this.defaultCurrency || '';
    const regionCode = currency.substring(0, 2);
    const info = this.getCurrencySymbol(currency);
    const shortSymbol = info.symbol.replace(regionCode, '');
    const alphabeticCharacters = /[A-Za-zÀ-ÖØ-öø-ÿĀ-ɏḂ-ỳ]/;
    return alphabeticCharacters.exec(shortSymbol) ? info : {
      symbol: shortSymbol,
      prefixed: info.prefixed
    };
  }

  humanizeDate(date, options) {
    if (dates.isFutureDate(date)) {
      return this.humanizeFutureDate(date, options);
    } else {
      return this.humanizePastDate(date, options);
    }
  }

  humanizePastDate(date, options) {
    if (dates.isLessThanOneMinuteAgo(date)) {
      return this.translate('date.humanize.lessThanOneMinuteAgo');
    }

    if (dates.isLessThanOneHourAgo(date)) {
      const now = new Date();
      const minutes = Math.floor((now.getTime() - date.getTime()) / dates.TimeUnit.Minute);
      return this.translate('date.humanize.lessThanOneHourAgo', {
        count: minutes
      });
    }

    const timeZone = options === null || options === void 0 ? void 0 : options.timeZone;
    const time = this.getTimeFromDate(date, options);

    if (dates.isToday(date, timeZone)) {
      return time;
    }

    if (dates.isYesterday(date, timeZone)) {
      return this.translate('date.humanize.yesterday', {
        time
      });
    }

    if (dates.isLessThanOneWeekAgo(date)) {
      const weekday = this.getWeekdayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneWeekAgo', {
        weekday,
        time
      });
    }

    if (dates.isLessThanOneYearAgo(date)) {
      const monthDay = this.getMonthDayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneYearAgo', {
        date: monthDay,
        time
      });
    }

    return this.formatDate(date, _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, options), {}, {
      style: index.DateStyle.Short
    }));
  }

  humanizeFutureDate(date, options) {
    const timeZone = options === null || options === void 0 ? void 0 : options.timeZone;
    const time = this.getTimeFromDate(date, options);

    if (dates.isToday(date, timeZone)) {
      return this.translate('date.humanize.today', {
        time
      });
    }

    if (dates.isTomorrow(date, timeZone)) {
      return this.translate('date.humanize.tomorrow', {
        time
      });
    }

    if (dates.isLessThanOneWeekAway(date)) {
      const weekday = this.getWeekdayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneWeekAway', {
        weekday,
        time
      });
    }

    if (dates.isLessThanOneYearAway(date)) {
      const monthDay = this.getMonthDayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneYearAway', {
        date: monthDay,
        time
      });
    }

    return this.formatDate(date, _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, options), {}, {
      style: index.DateStyle.Short
    }));
  }

  getTimeZone(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      timeZone
    } = options || {};
    const hourZone = this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      timeZone,
      hour12: false,
      timeZoneName: 'short',
      hour: 'numeric'
    });
    const zoneMatchGroup = /\s([\w()+\-:.]+$)/.exec(hourZone);
    return zoneMatchGroup ? zoneMatchGroup[1] : '';
  }

  getTimeFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      timeZoneName
    } = options || {};
    const formattedTime = this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      timeZoneName: timeZoneName === 'short' ? undefined : timeZoneName,
      hour: 'numeric',
      minute: '2-digit'
    }).toLocaleLowerCase();
    const time = timeZoneName === 'short' ? `${formattedTime} ${this.getTimeZone(date, options)}` : formattedTime;
    return string.convertFirstSpaceToNonBreakingSpace(time);
  }

  getWeekdayFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone
    } = options || {};
    return this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      weekday: 'long'
    });
  }

  getMonthDayFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone
    } = options || {};
    return this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      month: 'short',
      day: 'numeric'
    });
  }

  normalizedNumber(input, decimalSymbol, decimalPlaces = currencyDecimalPlaces.DEFAULT_DECIMAL_PLACES) {
    const maximumDecimalPlaces = Math.max(decimalPlaces, currencyDecimalPlaces.DEFAULT_DECIMAL_PLACES);
    const lastIndexOfPeriod = input.lastIndexOf(PERIOD);
    let lastIndexOfDecimal = input.lastIndexOf(decimalSymbol); // For locales that do not use period as the decimal symbol, users may still input a period
    // and expect it to be treated as the decimal symbol for their locale.

    if (decimalSymbol !== PERIOD && (input.match(REGEX_PERIODS) || []).length === 1 && this.decimalValue(input, lastIndexOfPeriod).length <= maximumDecimalPlaces) {
      lastIndexOfDecimal = lastIndexOfPeriod;
    }

    const integerValue = this.integerValue(input, lastIndexOfDecimal);
    const decimalValue = this.decimalValue(input, lastIndexOfDecimal);
    const isNegative = input.trim().startsWith(NEGATIVE_SIGN);
    const negativeSign = isNegative ? NEGATIVE_SIGN : '';
    const normalizedDecimal = lastIndexOfDecimal === -1 ? '' : PERIOD;
    const normalizedValue = `${negativeSign}${integerValue}${normalizedDecimal}${decimalValue}`;
    return normalizedValue.match(REGEX_DIGITS) ? normalizedValue : '';
  }

  integerValue(input, lastIndexOfDecimal) {
    return input.substring(0, lastIndexOfDecimal).replace(REGEX_NON_DIGITS, '');
  }

  decimalValue(input, lastIndexOfDecimal) {
    return input.substring(lastIndexOfDecimal + 1).replace(REGEX_NON_DIGITS, '');
  }

  isTranslateOptions(object) {
    return 'scope' in object;
  }

  defaultOnError(error) {
    throw error;
  }

}, (_rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "numberSymbols", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "numberSymbols"), _class.prototype)), _class));

exports.I18n = I18n;
