import { objectSpread2 as _objectSpread2 } from '../_virtual/_rollupPluginBabelHelpers.mjs';
import React from 'react';
import { memoize } from '@shopify/function-enhancers';
import { pseudotranslate } from '@shopify/i18n';
import { MissingTranslationError, MissingReplacementError } from '../errors.mjs';

const REPLACE_REGEX = /{([^}]*)}/g;
const MISSING_TRANSLATION = Symbol('Missing translation');
const PLURALIZATION_KEY_NAME = 'count';
const SEPARATOR = '.';
const numberFormats = new Map();
function memoizedNumberFormatter(locales, options) {
  const key = numberFormatCacheKey(locales, options);

  if (numberFormats.has(key)) {
    return numberFormats.get(key);
  }

  const i = new Intl.NumberFormat(locales, options);
  numberFormats.set(key, i);
  return i;
}
const PSEUDOTRANSLATE_OPTIONS = {
  startDelimiter: '{',
  endDelimiter: '}',
  prepend: '[!!',
  append: '!!]'
};
function numberFormatCacheKey(locales, options = {}) {
  const localeKey = Array.isArray(locales) ? locales.sort().join('-') : locales;
  return `${localeKey}-${JSON.stringify(options)}`;
}

function pluralRules(locale, options = {}) {
  return new Intl.PluralRules(locale, options);
}

const memoizedPluralRules = memoize(pluralRules, (locale, options = {}) => `${locale}${JSON.stringify(options)}`);
function getTranslationTree(id, translations, locale, replacements) {
  const normalizedTranslations = Array.isArray(translations) ? translations : [translations];
  let result;

  for (const translationDictionary of normalizedTranslations) {
    result = translationDictionary;

    for (const part of id.split(SEPARATOR)) {
      result = result[part];
      if (!result) break;
    }

    if (result) {
      if (replacements) {
        return typeof result === 'string' ? updateStringWithReplacements(result, replacements) : updateTreeWithReplacements(result, locale, replacements);
      }

      return result;
    }
  }

  throw new MissingTranslationError(id, locale);
}
function translate(id, options, translations, locale) {
  const {
    scope,
    replacements,
    pseudotranslate
  } = options;
  const normalizedTranslations = Array.isArray(translations) ? translations : [translations];
  const normalizedId = normalizeIdentifier(id, scope);

  for (const translationDictionary of normalizedTranslations) {
    const result = translateWithDictionary(normalizedId, translationDictionary, locale, replacements, {
      pseudotranslate
    });

    if (result !== MISSING_TRANSLATION) {
      return result;
    }
  }

  throw new MissingTranslationError(normalizedId, locale);
}

function translateWithDictionary(id, translations, locale, replacements, {
  pseudotranslate: pseudotranslate$1 = false
} = {}) {
  let result = translations;

  for (const part of id.split(SEPARATOR)) {
    if (result == null || typeof result !== 'object') {
      return MISSING_TRANSLATION;
    }

    result = result[part];
  }

  const additionalReplacements = {};

  if (typeof result === 'object' && replacements != null && Object.prototype.hasOwnProperty.call(replacements, PLURALIZATION_KEY_NAME)) {
    const count = replacements[PLURALIZATION_KEY_NAME];

    if (typeof count === 'number') {
      const group = memoizedPluralRules(locale).select(count);
      result = result[group];
      additionalReplacements[PLURALIZATION_KEY_NAME] = memoizedNumberFormatter(locale).format(count);
    }
  }

  const processedString = typeof result === 'string' && pseudotranslate$1 ? pseudotranslate(result, _objectSpread2(_objectSpread2({}, PSEUDOTRANSLATE_OPTIONS), {}, {
    toLocale: typeof pseudotranslate$1 === 'boolean' ? undefined : pseudotranslate$1
  })) : result;

  if (typeof processedString === 'string') {
    return updateStringWithReplacements(processedString, _objectSpread2(_objectSpread2({}, replacements), additionalReplacements));
  } else {
    return MISSING_TRANSLATION;
  }
}

function updateStringWithReplacements(str, replacements = {}) {
  const replaceFinder = /([^{]*)({([^}]*)})?/g;
  const allReplacementsArePrimitives = Object.keys(replacements).every(key => typeof replacements[key] !== 'object');

  if (allReplacementsArePrimitives) {
    return str.replace(REPLACE_REGEX, match => {
      const replacement = match.substring(1, match.length - 1);

      if (!Object.prototype.hasOwnProperty.call(replacements, replacement)) {
        throw new MissingReplacementError(replacement, replacements);
      }

      return replacements[replacement];
    });
  } else {
    const pieces = [];
    let match = replaceFinder.exec(str);
    let matchIndex = 0;

    while (match) {
      const regularText = match[1];
      const replacement = match[3];

      if (match.index >= str.length) {
        break;
      }

      if (regularText) {
        pieces.push(regularText);
      }

      if (replacement) {
        if (!Object.prototype.hasOwnProperty.call(replacements, replacement)) {
          throw new MissingReplacementError(replacement, replacements);
        }

        matchIndex += 1;
        const finalReplacement = /*#__PURE__*/React.isValidElement(replacements[replacement]) ? /*#__PURE__*/React.cloneElement(replacements[replacement], {
          key: matchIndex
        }) : replacements[replacement];
        pieces.push(finalReplacement);
      }

      match = replaceFinder.exec(str);
    }

    replaceFinder.lastIndex = 0;
    return pieces;
  }
}

function normalizeIdentifier(id, scope) {
  if (scope == null) {
    return id;
  }

  return `${typeof scope === 'string' ? scope : scope.join(SEPARATOR)}${SEPARATOR}${id}`;
}

function updateTreeWithReplacements(translationTree, locale, replacements) {
  if (Object.prototype.hasOwnProperty.call(replacements, PLURALIZATION_KEY_NAME)) {
    const count = replacements[PLURALIZATION_KEY_NAME];

    if (typeof count === 'number') {
      const group = memoizedPluralRules(locale).select(count);

      if (typeof translationTree[group] === 'string') {
        return updateStringWithReplacements(translationTree[group], _objectSpread2(_objectSpread2({}, replacements), {}, {
          PLURALIZATION_KEY_NAME: memoizedNumberFormatter(locale).format(count)
        }));
      }
    }
  }

  return Object.keys(translationTree).reduce((acc, key) => _objectSpread2(_objectSpread2({}, acc), {}, {
    [key]: typeof translationTree[key] === 'string' ? updateStringWithReplacements(translationTree[key], replacements) : updateTreeWithReplacements(translationTree[key], locale, replacements)
  }), {});
}

export { PSEUDOTRANSLATE_OPTIONS, getTranslationTree, memoizedNumberFormatter, memoizedPluralRules, numberFormatCacheKey, translate };
