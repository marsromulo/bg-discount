import { applyDecoratedDescriptor as _applyDecoratedDescriptor } from './_virtual/_rollupPluginBabelHelpers.esnext';
import { formatDate, isFutureDate, isLessThanOneMinuteAgo, isLessThanOneHourAgo, TimeUnit, isToday, isYesterday, isLessThanOneWeekAgo, isLessThanOneYearAgo, isTomorrow, isLessThanOneWeekAway, isLessThanOneYearAway } from '@shopify/dates';
import { memoize } from '@shopify/decorators';
import { languageFromLocale, regionFromLocale } from '@shopify/i18n';
import { LanguageDirection } from './types.esnext';
import { RTL_LANGUAGES, DateStyle, dateStyle, WEEK_START_DAYS, DEFAULT_WEEK_START_DAY, EASTERN_NAME_ORDER_FORMATTERS } from './constants/index.esnext';
import { MissingCurrencyCodeError, MissingCountryError } from './errors.esnext';
import { translate, getTranslationTree, memoizedNumberFormatter, memoizedPluralRules } from './utilities/translate.esnext';
import currencyDecimalPlaces, { DEFAULT_DECIMAL_PLACES } from './constants/currency-decimal-places.esnext';
import { getCurrencySymbol } from './utilities/money.esnext';
import { convertFirstSpaceToNonBreakingSpace } from './utilities/string.esnext';

var _dec, _class;
// Used for currencies that don't use fractional units (eg. JPY)
const PERIOD = '.';
const NEGATIVE_SIGN = '-';
const REGEX_DIGITS = /\d/g;
const REGEX_NON_DIGITS = /\D/g;
const REGEX_PERIODS = /\./g;
let I18n = (_dec = memoize(), (_class = class I18n {
  get language() {
    return languageFromLocale(this.locale);
  }

  get region() {
    return regionFromLocale(this.locale);
  }
  /**
   * @deprecated Use I18n#region instead.
   */


  get countryCode() {
    return regionFromLocale(this.locale);
  }

  get languageDirection() {
    return RTL_LANGUAGES.includes(this.language) ? LanguageDirection.Rtl : LanguageDirection.Ltr;
  }

  get isRtlLanguage() {
    return this.languageDirection === LanguageDirection.Rtl;
  }

  get isLtrLanguage() {
    return this.languageDirection === LanguageDirection.Ltr;
  }

  constructor(translations, {
    locale,
    currency: _currency,
    timezone,
    country,
    pseudolocalize = false,
    onError,
    loading
  }) {
    this.translations = translations;
    this.locale = void 0;
    this.pseudolocalize = void 0;
    this.defaultCountry = void 0;
    this.defaultCurrency = void 0;
    this.defaultTimezone = void 0;
    this.onError = void 0;
    this.loading = void 0;

    this.getCurrencySymbol = currencyCode => {
      const currency = currencyCode || this.defaultCurrency;

      if (currency == null) {
        throw new MissingCurrencyCodeError('formatCurrency cannot be called without a currency code.');
      }

      return this.getCurrencySymbolLocalized(this.locale, currency);
    };

    this.locale = locale;
    this.defaultCountry = country;
    this.defaultCurrency = _currency;
    this.defaultTimezone = timezone;
    this.pseudolocalize = pseudolocalize;
    this.onError = onError || this.defaultOnError;
    this.loading = loading || false;
  }

  translate(id, optionsOrReplacements, replacements) {
    const {
      pseudolocalize
    } = this;
    let normalizedOptions;

    if (optionsOrReplacements == null) {
      normalizedOptions = {
        pseudotranslate: pseudolocalize
      };
    } else if (this.isTranslateOptions(optionsOrReplacements)) {
      normalizedOptions = { ...optionsOrReplacements,
        replacements,
        pseudotranslate: pseudolocalize
      };
    } else {
      normalizedOptions = {
        replacements: optionsOrReplacements,
        pseudotranslate: pseudolocalize
      };
    }

    try {
      return translate(id, normalizedOptions, this.translations, this.locale);
    } catch (error) {
      this.onError(error);
      return '';
    }
  }

  getTranslationTree(id, replacements) {
    try {
      if (!replacements) {
        return getTranslationTree(id, this.translations, this.locale);
      }

      return getTranslationTree(id, this.translations, this.locale, replacements);
    } catch (error) {
      this.onError(error);
      return '';
    }
  }

  translationKeyExists(id) {
    try {
      getTranslationTree(id, this.translations, this.locale);
      return true;
    } catch (error) {
      return false;
    }
  }

  formatNumber(amount, {
    as,
    precision,
    ...options
  } = {}) {
    const {
      locale,
      defaultCurrency: currency
    } = this;

    if (as === 'currency' && currency == null && options.currency == null) {
      this.onError(new MissingCurrencyCodeError(`formatNumber(amount, {as: 'currency'}) cannot be called without a currency code.`));
      return '';
    }

    return memoizedNumberFormatter(locale, {
      style: as,
      maximumFractionDigits: precision,
      currency,
      ...options
    }).format(amount);
  }

  unformatNumber(input) {
    const {
      decimalSymbol
    } = this.numberSymbols();
    const normalizedValue = this.normalizedNumber(input, decimalSymbol);
    return normalizedValue === '' ? '' : parseFloat(normalizedValue).toString();
  }

  formatCurrency(amount, {
    form,
    ...options
  } = {}) {
    switch (form) {
      case 'auto':
        return this.formatCurrencyAuto(amount, options);

      case 'explicit':
        return this.formatCurrencyExplicit(amount, options);

      case 'short':
        return this.formatCurrencyShort(amount, options);

      case 'none':
        return this.formatCurrencyNone(amount, options);
    }

    return this.formatNumber(amount, {
      as: 'currency',
      ...options
    });
  }

  unformatCurrency(input, currencyCode) {
    const {
      decimalSymbol
    } = this.numberSymbols();
    const decimalPlaces = currencyDecimalPlaces.get(currencyCode.toUpperCase());
    const normalizedValue = this.normalizedNumber(input, decimalSymbol, decimalPlaces);

    if (normalizedValue === '') {
      return '';
    }

    if (decimalPlaces === 0) {
      const roundedAmount = parseFloat(normalizedValue).toFixed(0);
      return `${roundedAmount}.${'0'.repeat(DEFAULT_DECIMAL_PLACES)}`;
    }

    return parseFloat(normalizedValue).toFixed(decimalPlaces);
  }

  formatPercentage(amount, options = {}) {
    return this.formatNumber(amount, {
      as: 'percent',
      ...options
    });
  }

  formatDate(date, options = {}) {
    const {
      locale,
      defaultTimezone
    } = this;
    const {
      timeZone = defaultTimezone
    } = options;
    const {
      style = undefined,
      ...formatOptions
    } = options || {};

    if (style) {
      return style === DateStyle.Humanize ? this.humanizeDate(date, { ...formatOptions,
        timeZone
      }) : this.formatDate(date, { ...formatOptions,
        ...dateStyle[style]
      });
    }

    return formatDate(date, locale, { ...formatOptions,
      timeZone
    });
  }

  ordinal(amount) {
    const {
      locale
    } = this;
    const group = memoizedPluralRules(locale, {
      type: 'ordinal'
    }).select(amount);
    return this.translate(group, {
      scope: 'ordinal'
    }, {
      amount
    });
  }

  weekStartDay(argCountry) {
    const country = argCountry || this.defaultCountry;

    if (!country) {
      throw new MissingCountryError('weekStartDay() cannot be called without a country code.');
    }

    return WEEK_START_DAYS.get(country) || DEFAULT_WEEK_START_DAY;
  }

  getCurrencySymbolLocalized(locale, currency) {
    return getCurrencySymbol(locale, {
      currency
    });
  }

  formatName(firstName, lastName, options) {
    if (!firstName) {
      return lastName || '';
    }

    if (!lastName) {
      return firstName;
    }

    const isFullName = Boolean(options && options.full);
    const customNameFormatter = EASTERN_NAME_ORDER_FORMATTERS.get(this.locale) || EASTERN_NAME_ORDER_FORMATTERS.get(this.language);

    if (customNameFormatter) {
      return customNameFormatter(firstName, lastName, isFullName);
    }

    if (isFullName) {
      return `${firstName} ${lastName}`;
    }

    return firstName;
  }

  hasEasternNameOrderFormatter() {
    const easternNameOrderFormatter = EASTERN_NAME_ORDER_FORMATTERS.get(this.locale) || EASTERN_NAME_ORDER_FORMATTERS.get(this.language);
    return Boolean(easternNameOrderFormatter);
  }

  numberSymbols() {
    const formattedNumber = this.formatNumber(123456.7, {
      maximumFractionDigits: 1,
      minimumFractionDigits: 1
    });
    let thousandSymbol;
    let decimalSymbol;

    for (const char of formattedNumber) {
      if (isNaN(parseInt(char, 10))) {
        if (thousandSymbol) decimalSymbol = char;else thousandSymbol = char;
      }
    }

    return {
      thousandSymbol,
      decimalSymbol
    };
  }

  formatCurrencyAuto(amount, options = {}) {
    // use the short format if we can't determine a currency match, or if the
    // currencies match, use explicit when the currencies definitively do not
    // match.
    const formatShort = options.currency == null || this.defaultCurrency == null || options.currency === this.defaultCurrency;
    return formatShort ? this.formatCurrencyShort(amount, options) : this.formatCurrencyExplicit(amount, options);
  }

  formatCurrencyExplicit(amount, options = {}) {
    const value = this.formatCurrencyShort(amount, options);
    const isoCode = options.currency || this.defaultCurrency || '';

    if (value.includes(isoCode)) {
      return value;
    }

    return `${value} ${isoCode}`;
  }

  formatCurrencyShort(amount, options = {}) {
    const formattedAmount = this.formatCurrencyNone(amount, options);
    const shortSymbol = this.getShortCurrencySymbol(options.currency);
    const formattedWithSymbol = shortSymbol.prefixed ? `${shortSymbol.symbol}${formattedAmount}` : `${formattedAmount}${shortSymbol.symbol}`;
    return amount < 0 ? `-${formattedWithSymbol.replace(/[-−]/, '')}` : formattedWithSymbol;
  }

  formatCurrencyNone(amount, options = {}) {
    const {
      locale
    } = this;
    let adjustedPrecision = options.precision;

    if (adjustedPrecision === undefined) {
      const currency = options.currency || this.defaultCurrency || '';
      adjustedPrecision = currencyDecimalPlaces.get(currency.toUpperCase());
    }

    return memoizedNumberFormatter(locale, {
      style: 'decimal',
      minimumFractionDigits: adjustedPrecision,
      maximumFractionDigits: adjustedPrecision,
      ...options
    }).format(amount);
  } // Intl.NumberFormat sometimes annotates the "currency symbol" with a country code.
  // For example, in locale 'fr-FR', 'USD' is given the "symbol" of " $US".
  // This method strips out the country-code annotation, if there is one.
  // (So, for 'fr-FR' and 'USD', the return value would be " $").
  //
  // For other currencies, e.g. CHF and OMR, the "symbol" is the ISO currency code.
  // In those cases, we return the full currency code without stripping the country.


  getShortCurrencySymbol(currencyCode = this.defaultCurrency || '') {
    const currency = currencyCode || this.defaultCurrency || '';
    const regionCode = currency.substring(0, 2);
    const info = this.getCurrencySymbol(currency);
    const shortSymbol = info.symbol.replace(regionCode, '');
    const alphabeticCharacters = /[A-Za-zÀ-ÖØ-öø-ÿĀ-ɏḂ-ỳ]/;
    return alphabeticCharacters.exec(shortSymbol) ? info : {
      symbol: shortSymbol,
      prefixed: info.prefixed
    };
  }

  humanizeDate(date, options) {
    if (isFutureDate(date)) {
      return this.humanizeFutureDate(date, options);
    } else {
      return this.humanizePastDate(date, options);
    }
  }

  humanizePastDate(date, options) {
    if (isLessThanOneMinuteAgo(date)) {
      return this.translate('date.humanize.lessThanOneMinuteAgo');
    }

    if (isLessThanOneHourAgo(date)) {
      const now = new Date();
      const minutes = Math.floor((now.getTime() - date.getTime()) / TimeUnit.Minute);
      return this.translate('date.humanize.lessThanOneHourAgo', {
        count: minutes
      });
    }

    const timeZone = options === null || options === void 0 ? void 0 : options.timeZone;
    const time = this.getTimeFromDate(date, options);

    if (isToday(date, timeZone)) {
      return time;
    }

    if (isYesterday(date, timeZone)) {
      return this.translate('date.humanize.yesterday', {
        time
      });
    }

    if (isLessThanOneWeekAgo(date)) {
      const weekday = this.getWeekdayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneWeekAgo', {
        weekday,
        time
      });
    }

    if (isLessThanOneYearAgo(date)) {
      const monthDay = this.getMonthDayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneYearAgo', {
        date: monthDay,
        time
      });
    }

    return this.formatDate(date, { ...options,
      style: DateStyle.Short
    });
  }

  humanizeFutureDate(date, options) {
    const timeZone = options === null || options === void 0 ? void 0 : options.timeZone;
    const time = this.getTimeFromDate(date, options);

    if (isToday(date, timeZone)) {
      return this.translate('date.humanize.today', {
        time
      });
    }

    if (isTomorrow(date, timeZone)) {
      return this.translate('date.humanize.tomorrow', {
        time
      });
    }

    if (isLessThanOneWeekAway(date)) {
      const weekday = this.getWeekdayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneWeekAway', {
        weekday,
        time
      });
    }

    if (isLessThanOneYearAway(date)) {
      const monthDay = this.getMonthDayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneYearAway', {
        date: monthDay,
        time
      });
    }

    return this.formatDate(date, { ...options,
      style: DateStyle.Short
    });
  }

  getTimeZone(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      timeZone
    } = options || {};
    const hourZone = this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      timeZone,
      hour12: false,
      timeZoneName: 'short',
      hour: 'numeric'
    });
    const zoneMatchGroup = /\s([\w()+\-:.]+$)/.exec(hourZone);
    return zoneMatchGroup ? zoneMatchGroup[1] : '';
  }

  getTimeFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      timeZoneName
    } = options || {};
    const formattedTime = this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      timeZoneName: timeZoneName === 'short' ? undefined : timeZoneName,
      hour: 'numeric',
      minute: '2-digit'
    }).toLocaleLowerCase();
    const time = timeZoneName === 'short' ? `${formattedTime} ${this.getTimeZone(date, options)}` : formattedTime;
    return convertFirstSpaceToNonBreakingSpace(time);
  }

  getWeekdayFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone
    } = options || {};
    return this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      weekday: 'long'
    });
  }

  getMonthDayFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone
    } = options || {};
    return this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      month: 'short',
      day: 'numeric'
    });
  }

  normalizedNumber(input, decimalSymbol, decimalPlaces = DEFAULT_DECIMAL_PLACES) {
    const maximumDecimalPlaces = Math.max(decimalPlaces, DEFAULT_DECIMAL_PLACES);
    const lastIndexOfPeriod = input.lastIndexOf(PERIOD);
    let lastIndexOfDecimal = input.lastIndexOf(decimalSymbol); // For locales that do not use period as the decimal symbol, users may still input a period
    // and expect it to be treated as the decimal symbol for their locale.

    if (decimalSymbol !== PERIOD && (input.match(REGEX_PERIODS) || []).length === 1 && this.decimalValue(input, lastIndexOfPeriod).length <= maximumDecimalPlaces) {
      lastIndexOfDecimal = lastIndexOfPeriod;
    }

    const integerValue = this.integerValue(input, lastIndexOfDecimal);
    const decimalValue = this.decimalValue(input, lastIndexOfDecimal);
    const isNegative = input.trim().startsWith(NEGATIVE_SIGN);
    const negativeSign = isNegative ? NEGATIVE_SIGN : '';
    const normalizedDecimal = lastIndexOfDecimal === -1 ? '' : PERIOD;
    const normalizedValue = `${negativeSign}${integerValue}${normalizedDecimal}${decimalValue}`;
    return normalizedValue.match(REGEX_DIGITS) ? normalizedValue : '';
  }

  integerValue(input, lastIndexOfDecimal) {
    return input.substring(0, lastIndexOfDecimal).replace(REGEX_NON_DIGITS, '');
  }

  decimalValue(input, lastIndexOfDecimal) {
    return input.substring(lastIndexOfDecimal + 1).replace(REGEX_NON_DIGITS, '');
  }

  isTranslateOptions(object) {
    return 'scope' in object;
  }

  defaultOnError(error) {
    throw error;
  }

}, (_applyDecoratedDescriptor(_class.prototype, "numberSymbols", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "numberSymbols"), _class.prototype)), _class));

export { I18n };
