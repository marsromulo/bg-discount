export declare type ArrayElement<T> = T extends (infer U)[] ? U : never;
export declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends infer TP ? TP extends (infer U)[] ? DeepPartial<U>[] : TP extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]> : T[P];
};
export declare type IfEmptyObject<Obj, If, Else = never> = keyof Obj extends {
    length: 0;
} ? If : Else;
export declare type IfAllOptionalKeys<Obj, If, Else = never> = NonOptionalKeys<Obj> extends {
    length: 0;
} ? If : Else;
export declare type IfAllNullableKeys<Obj, If, Else = never> = NonNullableKeys<Obj> extends {
    length: 0;
} ? If : Else;
export declare type NonOptionalKeys<T> = {
    [K in keyof T]-?: undefined extends T[K] ? never : K;
}[keyof T];
export declare type NonNullableKeys<T> = {
    [K in keyof T]-?: null extends T[K] ? never : K;
}[keyof T];
export declare type NoInfer<T> = {
    [K in keyof T]: T[K];
} & T;
declare type ReactStatics = 'displayName' | 'getDerivedStateFromProps' | 'getDerivedStateFromErrors' | 'childContextTypes' | 'contextType' | 'contextTypes' | 'getDefaultProps' | 'propTypes';
export declare type NonReactStatics<T> = Pick<T, Exclude<keyof T, ReactStatics>>;
export declare type ExtendedWindow<T> = Window & typeof globalThis & T;
declare type DeepOmitHelper<T, K> = {
    [P in keyof T]: T[P] extends infer TP ? TP extends (infer U)[] ? DeepOmit<U, K>[] : DeepOmit<TP, K> : T[P];
};
declare type Primitive = string | Function | number | boolean | Symbol | undefined | null;
export declare type DeepOmit<T, K> = T extends Primitive ? T : K extends keyof T ? Omit<DeepOmitHelper<T, K>, K> : DeepOmitHelper<T, K>;
export declare type DeepOmitArray<T extends any[], K> = {
    [P in keyof T]: DeepOmit<T[P], K>;
};
export declare type PartialSome<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export declare type RequireSome<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export {};
//# sourceMappingURL=types.d.ts.map